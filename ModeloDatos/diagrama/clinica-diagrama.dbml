Table persons {
  per_id int [pk, increment, note: "Identificador único de la persona"]
  per_txt_first_name varchar(100) [not null, note: "Nombre de la persona"]
  per_txt_last_name varchar(100) [not null, note: "Apellido de la persona"]
  per_txt_dni varchar(20) [null, note: "Documento de identidad (DNI)"]
  per_dat_birthdate date [null, note: "Fecha de nacimiento"]
  per_int_gender smallint [null, note: "Género (código numérico)"]
  per_txt_email varchar(254) [null, note: "Email de contacto"]
  per_txt_phone varchar(30) [null, note: "Teléfono de contacto"]
  per_txt_address varchar(200) [null, note: "Dirección postal"]
  per_sta_state smallint [not null, note: "Estado lógico de la persona"]
  per_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del registro"]
  per_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización"]
  per_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  Indexes {
    (per_txt_dni) [unique, name: "uq_persons_dni"]
  }
}

Table users {
  usr_idt_id int [pk, increment, note: "Identificador único del usuario"]
  per_id int [null, unique, note: "Referencia opcional a persona"]

  usr_txt_email varchar(254) [not null, note: "Email usado como credencial de login"]
  usr_txt_password varchar(100) [not null, note: "Hash de la contraseña"]
  usr_bol_email_verified boolean [not null, default: false, note: "Indica si el email fue verificado"]

  usr_sta_state smallint [not null, note: "Estado lógico del usuario"]
  usr_sta_employee_state smallint [not null, note: "Estado laboral del usuario"]

  usr_txt_email_verification_code varchar(60) [null, note: "Código para verificación de email"]
  usr_dat_email_verification_expires_at timestamp [null, note: "Expiración del código de verificación"]
  usr_int_email_verification_attempts smallint [not null, default: 0, note: "Cantidad de intentos de verificación"]
  usr_dat_email_verification_last_sent_at timestamp [null, note: "Último envío de verificación de email"]

  usr_txt_password_reset_token varchar(120) [null, note: "Token para restablecer contraseña"]
  usr_dat_password_reset_expires_at timestamp [null, note: "Expiración del token de reset"]
  usr_int_password_reset_attempts smallint [not null, default: 0, note: "Cantidad de intentos de reset"]
  usr_dat_password_reset_last_sent_at timestamp [null, note: "Último envío de reset de contraseña"]

  usr_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del usuario"]
  usr_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del usuario"]
  date_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  usr_int_token_version int [not null, default: 0, note: "Versión del token para invalidar sesiones activas"]

  Indexes {
    (usr_txt_email) [unique, name: "uq_users_email"]
  }
}

Table patients {
  pat_id int [pk, increment, note: "Identificador único del paciente"]
  per_id int [not null, unique, note: "Referencia obligatoria a persona"]
  pat_sta_state smallint [not null, note: "Estado del paciente"]
  pat_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del paciente"]
  pat_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del paciente"]
  pat_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]
}

Table doctors {
  doc_id int [pk, increment, note: "Identificador único del médico"]
  per_id int [not null, unique, note: "Referencia obligatoria a persona"]
  doc_txt_license varchar(30) [null, note: "Matrícula o licencia profesional"]
  doc_txt_specialty varchar(100) [null, note: "Especialidad médica"]
  doc_sta_state smallint [not null, note: "Estado del médico"]
  doc_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del médico"]
  doc_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del médico"]
  doc_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]
}

Table rol {
  id uuid [pk, note: "Identificador único del rol (UUID)"]
  rol_name varchar [not null, note: "Nombre del rol"]
  rol_description varchar(50) [null, note: "Descripción del rol"]
  rol_weight int [null, note: "Jerarquía o peso del rol"]

  Indexes {
    (rol_name) [unique, name: "uq_rol_name"]
  }
}

Table usr_rol {
  user_id int [not null, note: "Usuario al que se le asigna el rol"]
  rol_id uuid [not null, note: "Rol asignado al usuario"]

  Indexes {
    (user_id, rol_id) [pk, name: "pk_usr_rol"]
  }
}

Table refresh_token {
  rtk_id uuid [pk, note: "Identificador único del refresh token"]
  user_id int [not null, note: "Usuario propietario del refresh token"]
  rtk_txt_hash varchar(64) [not null, note: "Hash del refresh token"]
  rtk_dat_expires_at timestamp [not null, note: "Fecha de expiración"]
  rtk_dat_revoked_at timestamp [null, note: "Fecha de revocación"]
  rtk_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación"]
  rtk_dat_last_used_at timestamp [null, note: "Último uso del refresh token"]
  rtk_txt_user_agent varchar(200) [null, note: "User-Agent del cliente"]
  rtk_txt_ip varchar(45) [null, note: "IP del cliente"]

  Indexes {
    (rtk_txt_hash) [unique, name: "uq_refresh_token_hash"]
    (user_id) [name: "idx_refresh_token_user"]
  }
}
Table appointments {
  app_id int [pk, increment, note: "Identificador único del turno"]

  pat_id int [not null, note: "Paciente del turno"]
  doc_id int [not null, note: "Médico del turno"]

  app_dat_start_at timestamp [not null, note: "Inicio del turno"]
  app_dat_end_at timestamp [not null, note: "Fin del turno"]

  app_sta_status smallint [not null, note: "Estado del turno (programado/confirmado/cancelado/ausente/atendido, etc.)"]

  app_txt_reason varchar(200) [null, note: "Motivo o razón del turno"]
  app_txt_notes varchar(500) [null, note: "Notas internas del turno"]

  app_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación"]
  app_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización"]
  app_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  Indexes {
    (doc_id, app_dat_start_at) [name: "idx_appointments_doc_start"]
    (pat_id, app_dat_start_at) [name: "idx_appointments_pat_start"]
    (app_sta_status) [name: "idx_appointments_status"]
  }
}

Table doctor_availability {
  dav_id int [pk, increment, note: "Identificador único de disponibilidad"]

  doc_id int [not null, note: "Médico al que pertenece la disponibilidad"]

  dav_int_day_of_week smallint [not null, note: "Día de semana (0-6)"]
  dav_tim_start_time time [not null, note: "Hora de inicio (hora local)"]
  dav_tim_end_time time [not null, note: "Hora de fin (hora local)"]

  dav_int_slot_minutes smallint [not null, note: "Duración del slot (minutos)"]
  dav_sta_state smallint [not null, note: "Estado (activo/inactivo)"]

  dav_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación"]
  dav_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización"]
  dav_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  Indexes {
    (doc_id, dav_int_day_of_week) [name: "idx_dav_doc_dow"]
    (doc_id) [name: "idx_dav_doc"]
  }
}

Table doctor_time_off {
  dto_id int [pk, increment, note: "Identificador único del bloqueo/ausencia"]

  doc_id int [not null, note: "Médico al que se le bloquea la agenda"]

  dto_dat_start_at timestamp [not null, note: "Inicio del bloqueo"]
  dto_dat_end_at timestamp [not null, note: "Fin del bloqueo"]

  dto_txt_reason varchar(200) [null, note: "Motivo del bloqueo (vacaciones, feriado, congreso, etc.)"]
  dto_sta_state smallint [not null, note: "Estado (activo/inactivo)"]

  dto_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación"]
  dto_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización"]
  dto_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  Indexes {
    (doc_id, dto_dat_start_at) [name: "idx_dto_doc_start"]
    (doc_id) [name: "idx_dto_doc"]
  }
}

Table modules {
  mod_id int [pk, increment, note: "Identificador único del módulo"]
  mod_txt_key varchar(60) [not null, unique, note: "Key única (ej: appointments, patients)"]
  mod_txt_name varchar(100) [not null, note: "Nombre visible"]
  mod_int_order int [not null, default: 0, note: "Orden para menú"]
  mod_sta_state smallint [not null, note: "Estado lógico"]
  mod_dat_created_at timestamp [not null, default: `now()`]
  mod_dat_updated_at timestamp [not null, default: `now()`]
  mod_dat_deleted_at timestamp [null]
  mod_path_to varchar(60) [not null, note: "redireccion"]

  Indexes {
    (mod_txt_key) [unique, name: "uq_modules_key"]
  }
}

Table submodules {
  sub_id int [pk, increment, note: "Identificador único del submódulo"]
  mod_id int [not null, note: "FK al módulo"]
  sub_txt_key varchar(60) [not null, note: "Key dentro del módulo (ej: calendar, availability)"]
  sub_txt_name varchar(100) [not null, note: "Nombre visible"]
  sub_int_order int [not null, default: 0, note: "Orden para menú"]
  sub_sta_state smallint [not null, note: "Estado lógico"]
  sub_dat_created_at timestamp [not null, default: `now()`]
  sub_dat_updated_at timestamp [not null, default: `now()`]
  sub_dat_deleted_at timestamp [null]
  sub_path_to varchar(60) [not null, note: "redireccion"]
  sub_icon varchar (60) [note : "icono de material ui"]

  Indexes {
    (mod_id, sub_txt_key) [unique, name: "uq_submodules_mod_key"]
    (mod_id) [name: "idx_submodules_mod"]
  }
}

  Table rol_permission {
    rpe_id int [pk, increment, note: "pk de la tabla"]
    rol_id uuid [not null, note: "FK rol.id"]


    rpe_bol_can_write boolean [not null, default: false, note: "Permiso escritura"]
    rpe_bol_can_read boolean [not null, default: false, note: "Permiso de lectura"]
    rpe_dat_created_at timestamp [not null, default: `now()`]
    rpe_dat_updated_at timestamp [not null, default: `now()`]

    rpe_permission_txt_name varchar(120) [not null, note:"nombre del permiso"]
    rpe_permission_txt_description varchar(120) [not null, note:"descripcion del permiso"]

  Indexes {
    (rol_id, rpe_permission_txt_name) [unique, name:
  "uq_rol_permission_role_name"]
    (rol_id) [name: "idx_rol_permission_rol"]
  }
  }
Ref: submodules.mod_id > modules.mod_id [delete: cascade]
Ref: rol_permission.rol_id > rol.id [delete: cascade]

Ref: appointments.pat_id > patients.pat_id [delete: cascade]
Ref: appointments.doc_id > doctors.doc_id [delete: cascade]

Ref: doctor_availability.doc_id > doctors.doc_id [delete: cascade]
Ref: doctor_time_off.doc_id > doctors.doc_id [delete: cascade]

Ref: users.per_id > persons.per_id [delete: set null]

Ref: patients.per_id > persons.per_id [delete: cascade]

Ref: doctors.per_id > persons.per_id [delete: cascade]

Ref: usr_rol.user_id > users.usr_idt_id [delete: cascade]

Ref: usr_rol.rol_id > rol.id [delete: cascade]

Ref: refresh_token.user_id > users.usr_idt_id [delete: cascade]
