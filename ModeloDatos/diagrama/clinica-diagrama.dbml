Table persons {
  per_id int [pk, increment, note: "Identificador único de la persona"]
  per_txt_first_name varchar(100) [not null, note: "Nombre de la persona"]
  per_txt_last_name varchar(100) [not null, note: "Apellido de la persona"]
  per_txt_dni varchar(20) [null, note: "Documento de identidad (DNI)"]
  per_dat_birthdate date [null, note: "Fecha de nacimiento"]
  per_int_gender smallint [null, note: "Género (código numérico)"]
  per_txt_email varchar(254) [null, note: "Email de contacto"]
  per_txt_phone varchar(30) [null, note: "Teléfono de contacto"]
  per_txt_address varchar(200) [null, note: "Dirección postal"]
  per_sta_state smallint [not null, note: "Estado lógico de la persona"]
  per_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del registro"]
  per_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización"]
  per_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  Indexes {
    (per_txt_dni) [unique, name: "uq_persons_dni"]
  }
}

Table users {
  usr_idt_id int [pk, increment, note: "Identificador único del usuario"]
  per_id int [null, unique, note: "Referencia opcional a persona"]

  usr_txt_email varchar(254) [not null, note: "Email usado como credencial de login"]
  usr_txt_password varchar(100) [not null, note: "Hash de la contraseña"]
  usr_bol_email_verified boolean [not null, default: false, note: "Indica si el email fue verificado"]

  usr_sta_state smallint [not null, note: "Estado lógico del usuario"]
  usr_sta_employee_state smallint [not null, note: "Estado laboral del usuario"]

  usr_txt_email_verification_code varchar(60) [null, note: "Código para verificación de email"]
  usr_dat_email_verification_expires_at timestamp [null, note: "Expiración del código de verificación"]
  usr_int_email_verification_attempts smallint [not null, default: 0, note: "Cantidad de intentos de verificación"]
  usr_dat_email_verification_last_sent_at timestamp [null, note: "Último envío de verificación de email"]

  usr_txt_password_reset_token varchar(120) [null, note: "Token para restablecer contraseña"]
  usr_dat_password_reset_expires_at timestamp [null, note: "Expiración del token de reset"]
  usr_int_password_reset_attempts smallint [not null, default: 0, note: "Cantidad de intentos de reset"]
  usr_dat_password_reset_last_sent_at timestamp [null, note: "Último envío de reset de contraseña"]

  usr_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del usuario"]
  usr_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del usuario"]
  date_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]

  usr_int_token_version int [not null, default: 0, note: "Versión del token para invalidar sesiones activas"]

  Indexes {
    (usr_txt_email) [unique, name: "uq_users_email"]
  }
}

Table patients {
  pat_id int [pk, increment, note: "Identificador único del paciente"]
  per_id int [not null, unique, note: "Referencia obligatoria a persona"]
  pat_sta_state smallint [not null, note: "Estado del paciente"]
  pat_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del paciente"]
  pat_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del paciente"]
  pat_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]
}

Table doctors {
  doc_id int [pk, increment, note: "Identificador único del médico"]
  per_id int [not null, unique, note: "Referencia obligatoria a persona"]
  doc_txt_license varchar(30) [null, note: "Matrícula o licencia profesional"]
  doc_txt_specialty varchar(100) [null, note: "Especialidad médica"]
  doc_sta_state smallint [not null, note: "Estado del médico"]
  doc_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación del médico"]
  doc_dat_updated_at timestamp [not null, default: `now()`, note: "Fecha de última actualización del médico"]
  doc_dat_deleted_at timestamp [null, note: "Fecha de borrado lógico (soft delete)"]
}

Table rol {
  id uuid [pk, note: "Identificador único del rol (UUID)"]
  rol_name varchar [not null, note: "Nombre del rol"]
  rol_description varchar(50) [null, note: "Descripción del rol"]
  rol_weight int [null, note: "Jerarquía o peso del rol"]

  Indexes {
    (rol_name) [unique, name: "uq_rol_name"]
  }
}

Table usr_rol {
  user_id int [not null, note: "Usuario al que se le asigna el rol"]
  rol_id uuid [not null, note: "Rol asignado al usuario"]

  Indexes {
    (user_id, rol_id) [pk, name: "pk_usr_rol"]
  }
}

Table refresh_token {
  rtk_id uuid [pk, note: "Identificador único del refresh token"]
  user_id int [not null, note: "Usuario propietario del refresh token"]
  rtk_txt_hash varchar(64) [not null, note: "Hash del refresh token"]
  rtk_dat_expires_at timestamp [not null, note: "Fecha de expiración"]
  rtk_dat_revoked_at timestamp [null, note: "Fecha de revocación"]
  rtk_dat_created_at timestamp [not null, default: `now()`, note: "Fecha de creación"]
  rtk_dat_last_used_at timestamp [null, note: "Último uso del refresh token"]
  rtk_txt_user_agent varchar(200) [null, note: "User-Agent del cliente"]
  rtk_txt_ip varchar(45) [null, note: "IP del cliente"]

  Indexes {
    (rtk_txt_hash) [unique, name: "uq_refresh_token_hash"]
    (user_id) [name: "idx_refresh_token_user"]
  }
}

Ref: users.per_id > persons.per_id [delete: set null]

Ref: patients.per_id > persons.per_id [delete: cascade]

Ref: doctors.per_id > persons.per_id [delete: cascade]

Ref: usr_rol.user_id > users.usr_idt_id [delete: cascade]

Ref: usr_rol.rol_id > rol.id [delete: cascade]

Ref: refresh_token.user_id > users.usr_idt_id [delete: cascade]
